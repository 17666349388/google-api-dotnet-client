{% doc_comment noblock %}
Implements the {{ method.name }} method.

@ingroup ServiceMethod

This class uses the Command Pattern. Construct an instance with the required parameters, then set any additional optional parameters by using the attribute setters. To invoke the method, call <code>Execute</code>.
{% if method.scopes %}
The required authorization scopes for this method are:
"{{ method.scopes|join:"+" }}"
{% else %}
No authorization scopes are required for this method.
{% endif %}
{% enddoc_comment %}
class {{ method.className }} : public {{ api.className }}BaseRequest {
 public:{% indent %}
{% doc_comment noblock %}
The standard constructor takes all the required method parameters.
@param[in] _service_  The service instance to send to when executed.
@param[in] _credential_  If not NULL, the credential to authorize with.
           In practice this is supplied by the user code that is
           creating the method instance.{% for p in method.requiredParameters %}
@param[in] {{ p.codeName }} {{ p.description }}
{% endfor %}{% if method.requestType and not method.mediaUpload %}
@param[in] _content_ The data object to {{ method.name }}.
{% endif %}
{% enddoc_comment %}
{{ method.className }}({% indent %}
    const {{ api.className }}* _service_,
    {{ api.client_namespace }}::AuthorizationCredential* _credential_{% for p in method.requiredParameters %},
    const {{ p.parameterCodeType }}& {{ p.codeName }}{% endfor %}{% if method.requestType and not method.mediaUpload %},
    const {{ method.requestType.fullClassName }}& _content_{% endif %});{% endindent %}

{% doc_comment noblock %}
Standard destructor.
{% enddoc_comment %}
virtual ~{{ method.className }}();{% if method.parameters %}
{% call_template _access_method_attributes_h parameters=method.parameters %}

{% doc_comment noblock %}
Appends variable value to the target string.

This is a helper function used to resolve templated variables in the URI.

@param[in] variable_name  The name of the templated variable.
@param[in] config  A pass-through parameter used for lists and maps.
@param[in, out] target The string to append the value to.
{% enddoc_comment %}
virtual {{ api.status_type }} AppendVariable(
      const StringPiece& variable_name,
      const {{ api.client_namespace }}::UriTemplateConfig& config,
      string* target);
{% if method.queryParameters %}
{% doc_comment noblock %}
Appends the optional query parameters to the target URL.

@param[in, out] target  The URL string to append to.
{% enddoc_comment %}
virtual {{ api.status_type }} AppendOptionalQueryParameters(string* target);
{% endif %}{% endif %}
{% if method.responseType.className %}
{% doc_comment noblock %}
Executes the method and parses the response into a data object on success.

@param[out] data Loads from the response payload JSON data on success.

@return Success if an HTTP 2xx response was received. Otherwise the
        status indicates the reason for failure. Finer detail may be
        available from the underlying http_request to distinguish the
        transport_status from the overal HTTP request status.
{% enddoc_comment %}
{{ api.status_type }} ExecuteAndParseResponse(
    {{ method.responseType.className }}* data) {
  return {{ api.className }}BaseRequest::ExecuteAndParseResponse(data);
}
{% endif %}{% if method.mediaUpload %}
{% doc_comment noblock %}
Invokes the server with the method.

Response detail is available from the underlying http_request.

@return Success if an HTTP 2xx response was received. Otherwise the
        status indicates the reason for failure. Finer detail may be
        available from the underlying http_request to distinguish the
        transport_status from the overal HTTP request status.
{% enddoc_comment %}
virtual {{ api.status_type }} Execute();

{% doc_comment noblock %}
Returns MediaUploader for uploading the content.
{% enddoc_comment %}
{{ api.client_namespace }}::MediaUploader* media_uploader() {
  return _uploader_.get();
}
{% for key,value in method.mediaUpload.protocols.items %}
{% doc_comment noblock %}
Returns the specification for media upload using the {{ key }} protocol.
{% enddoc_comment %}
static const {{ api.client_namespace }}::MediaUploadSpec
  {{ key|upper }}_MEDIA_UPLOAD;{% endfor %}
{% endif %}{% if method.supportsMediaDownload %}
{% doc_comment noblock %}
Determine if the request should use Media Download for the response.

@return true for media download, false otherwise.
{% enddoc_comment %}
bool get_use_media_download() const   {
  return {{ api.className }}BaseRequest::get_use_media_download();
}

{% doc_comment noblock %}
Sets whether Media Download should be used for the response data.

@param[in] use true to use media download, false otherwise.
{% enddoc_comment %}
void set_use_media_download(bool use) {
  {{ api.className }}BaseRequest::set_use_media_download(use);
}
{% endif %}{% endindent %}
 private:
{% call_template _declare_method_attributes_h parameters=method.parameters %}{% if method.mediaUpload %}
  scoped_ptr<{{ api.client_namespace }}::MediaUploader> _uploader_;
{% else %}{% if method.requestType %}  string _content_;{% endif %}{% endif %}
  DISALLOW_COPY_AND_ASSIGN({{ method.className }});
};
{% if method.isPageable %}
typedef {{ api.client_namespace }}::ServiceRequestPager<
            {{ method.className }},
            {{ method.responseType.className }}>
        {{ method.className }}Pager;
{% endif %}
